백준 숫자뒤집어비교
https://www.acmicpc.net/source/3514355

https://blog.naver.com/ds030337/222453279984
1. cout.precision(n)
cout로 출력할 때 나타낼 자리수를 정하는 기능입니다.
정수부 + 소수부의 수를 n자리로 만듭니다.

bool
true 1/ false 0

stoi(string)
문자열값 정수변환

substr(시작위치, 길이)
문자열반환
시작위치는 인덱스 벗어나면 오류
길이는 인덱스 벗어나도 마지막까지만 반환하고 오류안남
getchar(위치)
char반환
stdio.h 헤더필요

삼항연산자
(조건문)? 참일때값:거짓일때값;
cout으로 바로출력하면 참거짓만 판별하는 듯

memset(배열이름, 초기화값(0만가능한듯), 배열의크기sizeof());
배열 초기화(for문보다 빠름)	

strcpy(_s) (문자열 변수,"문자 내용"or변수); #define _CRT_SECURE_NO_WARNINGS
해당 문자열 변수에 내용or 변수를 넣음 
변수 : char형 배열, 배열을 가리키는 포인터 가능
문자내용 : char형 배열, 배열을 가리키는 포인터, const char* 가능

변수.c_str()
string을 const char*로 변환

a.length() 
string 길이 반환

strlen(변수) 
변수 길이 반환
char형 배열, 배열을 가리키는 포인터, const char* 가능

sizeof(변수) 변수의 크기
sizeof(배열의크기)/sizeof(한원소의크기(*p)) = 배열 원소의 갯수

변수.at(변수) 해당 위치 문자 반환
변수.empty() 문자가 비어있는지 bool형 반환

a[100];
cin.getline(a, 100, '가');
최대 100자의 문자를 a에 저장
엔터로 구분 '가' 입력시 종료(생략가능)

헤더 .h빼고 앞에 c넣어라 (c++의 문법에 맞게 확장된 헤더를 쓸 수 있다.)
bit, byte = 8bit, kilo byte = 1024b, mega byte = 1024kb, giga byte = 1024mb
해당 값을 집어넣음 스트링헤더필요
int* array = new int[a] 동적할당
String b = "152496"; 
int[] A = new int[b.length()]; 문자열 길이 구하기
sprintf_s(chr, "%d", sum);
bool형식 true 상수로 1, false 상수로 0

string을 const char*형태로 배열에 넣어 출력
	string s = "안녕하세요";
	char n[100];
	strcpy(n,s.c_str());
	cout << n;
s.c_str()등의 함수는 값을 "리턴"하므로 원본은 바뀌지 않으니 식에 써야함

string char 형변환
https://blog.naver.com/yungtae1/222319332813
string함수 모음
https://hwan-shell.tistory.com/120


if(aa==bb) 
와 같은 것이 의미가 없다는 것이다. aa의 주소와 bb의 주소가 같음을 의미하니까!
문자열이 같음을 비교하기 위해서는 따로 함수가 있어야 한다.

문자열.append(추가 할 문자열)                        - string변수 추가 가능
문자열.append(추가 할 문자열, 문자수)
문자열.append(추가 할 문자열, 위치, 문자수) 

문자열.insert(추가할 문자열, 위치)

------------------------------------------------------------------------------------------------------------------------------TIP
return 0==1;  //false(0)출력됨 리턴에 조건문가능

자료형 n[n] ={}; 배열 전체 0 초기화

!는 변수에 붙이면 bool형식으로 인지하여 0일 때 1반환, other number일 때 0 반환 
char* 타입의 인자를 출력할 때는 주어진 주소로부터 널문자가 나올때까지 문자열로 취급하여 출력하도록 정의되어 있음
"string, char배열"은 &n[n]을 하면 주소가 아닌 "해당 인덱스부터 NULL까지의 값"이 출력됨
배열을 꽉채우면 NULL값이 들어갈 공간이 없어서 NULL값도 "해당 인덱스부터 NULL까지의 값" 끝에 포함되어 출력됨
-(void*)c, (void*)&c[1]등으로 주소출력 가능


------------------------------------------------------------------------------------------------------------------------------
int
	n: 값 	*n :x 	  &n: 주소	n[n]: x			*n[n]: x		&n[n]: x
char
	n: 값 	*n: x 	  &n: 주소	n[n]: x			*n[n]: x		&n[n]: x
string
	n: 값 	*n: x 	  &n: 주소	n[n]: x			*n[n]: x		&n[n]: n번째부터 모든 값
int[]
	n: 주소 	*n: 첫값 	  &n: 주소	n[n]: index 값		*n[n]: x		&n[n]: index 주소
char[]
n: 전체값+NULL?값 *n: 첫값    &n: 주소	n[n]: index 값		*n[n]: x		&n[n]: index부터값+NULL?값
string[]
	n: 주소 	*n: 첫값  &n: 주소      	n[n]: 주소(index가 아닌 첫)   *n[n]: x		&n[n]: index 주소
(동적할당 후)
int[]
            n: 포인터 주소 	*n: 첫값 	  &n: 배열주소	n[n]: index 값		*n[n]: x		&n[n]: index 주소
char[]
n: 전체값+NULL?값 	*n: 첫값    &n: 배열주소	n[n]: index 값		*n[n]: x		&n[n]: 전체값+NULL?값
string[]
            n: 포인터 주소 	*n: 첫값    &n: 배열주소 	n[n]: index 값		*n[n]: x		&n[n]: index 주소
------------------------------------------------------------------------------------------------------------------------------파라미터
함수 호출시 인자값이 전달되는 변수 
func (int a, int b){...}

int main()
{func(3,4);
}

에서, 인자값을 전달받는 a,b가 파라미터
------------------------------------------------------------------------------------------------------------------------------string 및 const char*
배열에서 한글은 2바이트, 숫자영어는 1바이트 (길이로 코드짤 때 주의) "한글은 배열도 두개씀"
string 은 int나 char 같은 기본 자료형이 아니며 문자들을 배열에 넣고 끝에0(NULL)을 붙인 형태이다
const char*에서 const 문자열을 변경하지 않겠다 라는 일종의 약속의 의미로 쓴다 (컴파일오류 방지로)
string값은 그냥 string에 옮기면 됨 덧셈도가능
string을 char포인터형으로 변환시 char[] 배열로 저장
char형 배열 및 const char*에 문자열 초기화 가능
"abc" 의 자료형은 const char [4] 이다

string "abc"는 const char[4]의 배열과 마찬가지이고 (abc뒤에null붙은 형태)
const char 배열의 반환값이 const char* 이므로 
const char * 형 변수를 넣어야하기 때문에 const char*을 인자로 받는다

배열은 연산 전에 주소로 변환된다
때문에 const int* ptr=35;가 안됨과 달리 const char* ptr="안녕하세요";가 가능하다

const char을 char에 넣을 순 있지만 char을 const char에 넣을순 없으므로
char배열에 const char을 넣을 수 있다
------------------------------------------------------------------------------------------------------------------------------부동소수점,고정소수점
고정소수점
일반적으로 우리가 사용하는 방식
부호,실수,소수로 구성
부동소수점
부동 -> 떠서 움직인다는 뜻 고정의 반댓말
부호,실수,소수점 위치를 나타내는 가수로 구성 
큰 수를 표현할 수 있지만 근삿값으로 표기됨

cout << fixed; -소수점 고정
#include <iomanip>후 cout << setprecision(상수);  - 부동소수점 정밀도 지정
------------------------------------------------------------------------------------------------------------------------------선언
int b; 후 int a = b = 0; 가능  >>b가 상수취급 되므로/ int a,b; 가능 but 초기화 따로필요/ int a,b = 0; 불가능 
------------------------------------------------------------------------------------------------------------------------------if문
if문 여러개 쓰면 조건에 여러개 만족하는경우 주의 (else if는 조건이 맞으면 다른 조건을 비교하지않으므로 다름)
------------------------------------------------------------------------------------------------------------------------------배열
배열에서 한글은 2바이트, 숫자영어는 1바이트 (길이로 코드짤 때 주의) "한글은 배열도 두개씀"
출력시 c[0]<<c[1]; 하면 2바이트로 간주하여 한글 출력 가능
array[] ={}; 배열 값 모두 0으로 초기화 array[5] ={0,1}; 배열크기가 더크므로 0,1 후 쓰레기값  array[1] ={0,1}; 값크기가 더크므로 배열의 크기는 array[2];까지
배열의 마지막은 항상 NULL값이 존재하므로 10개는 a[10]으로 선언
char chr[9] = {};
배열은 int 형식으로 정의해도 값이 여러개이므로 int로 리턴을 받는 함수로 리턴 불가
------------------------------------------------------------------------------------------------------------------------------기초연산 관련
/, *은 나오는 순서대로 계산
b<<2 2칸 shift ex)00001010 -> 00101000 (10>40)
(a>b)?a:b a가 b보다 크면 결과가 a 아니면 b
c=a++; c에 a대입후 a++
c=++a; a++ 후 c값에 대입
a +=b; a=a+b 줄임말
a&b 이진수 비트를 and연산
c= (a+b,a-b) 왼쪽연산 후 오른쪽연산 후 c에 치환
|| && 비교연산자
------------------------------------------------------------------------------------------------------------------------------switch문, continue
switch는 case a: ~~~; break; 안걸면 뒤에 케이스까지 출력
continue; = 조건 충족하면 다음과정 진행 - 해당값 제외하고 출력에 유용

함수원형을 미리 정의하면 main문 밑에 있어도 실행됨
------------------------------------------------------------------------------------------------------------------------------char과 int 형변환
char과 int는 "연산시에만(선언 형변환은 불가능)" 서로 형변환이 가능하며 입력을 받는 char은 아스키코드로 변환됨 입력을 받는 변수가 char일 경우
다시 아스키코드에 해당하는 문자로 변환 int일경우 문자의 아스키코드값 입력
------------------------------------------------------------------------------------------------------------------------------포인터와 배열
int형 포인터는 3.14를 받으면 3으로 변환
포인터는 가리키는곳 값을 뜻 포인터값이 바뀌면 가리키는 곳 값도 바뀜 NULL로 포인터 주소값 초기화
포인터와 배열에서 p=&p이며 n은 &n[0]을 뜻함 *(p + 5)는 &n[5]의 "값"이며, n+5나 p+5는 &n[5]의 주소임 정수형 포인터형식이기 때문에 n = n +1과 같은 연산은 불가
int* p=n; n이 int로 정의되어있으므로 형식이달라 x
int* p = &n; n이 주소형식이므로 o
int*p정의 후  *p=n; 포인터에 n값 저장
a[10]에서 a는 a[0]의 주소값을 뜻함
for문으로 배열 채워넣기 가능 p++;쓰면 채우면서 포인터 주소도 옮겨짐 p=n;으로 포인터위치 다시 &n[0]으로 초기화
------------------------------------------------------------------------------------------------------------------------------참조자
int num1 = 35;int &num2 = num1;와 같이 선언 초기화 된 변수만 지정가능
포인터도 포인터변수이므로 참조 가능 상수 참조 가능
하나의 "별칭", 값이 바뀌면 가리키는 값도 바뀜
포인터와의 차이
1.포인터는 null이 있지만 참조자는 없다 (포인터는 null로 초기화도 가능)
선언하며 초기화를 해줘야하기 때문 
2.참조자는 변수를 입력받고 포인터는 주소값을 입력받는다
3. 포인터는 가리키는 객체를 바꿀 수 있지만 참조자는 불가하다
공통점: 객체(변수)를 간접적으로 참조한다
반환형이 참조형인 경우에는 반환되는 대상을 참조자/변수로 받을 수 있다 그러나 반환형이 값의 형태라면, 참조자로 그 값을 받을 수 없다
지역변수를 참조의 형태로 반환하는 것은 문제의 소지가 된다 (지역변수가 소멸하므로 참조 불가능)
------------------------------------------------------------------------------------------------------------------------------const
constant의 약자"변함없는"
변수 앞에 붙이면 값과 주소를 변경할 수 없도록 만듦 -> 변수를 상수로 만듦
포인터의 앞에 사용하면 포인터가 상수이므로 값 변경x const int *ptr = &value;
뒤에 사용하면 주소가 상수이므로  주소 값 변경x
둘다 사용하면 둘다 변경x
-const int* p = &n; 상수를 가리키는 비 상수 포인터는 가리키는 값을 수정 불가능하지만 다른 변수를 가리키도록 자신의 주소를 바꿀 수 있다.
-int* const p = &n; 일반 변수를 가리키는 상수 포인터는 자신이 가리키는 주소를 수정 할 수 없지만 포인터가 가리키는 값을 변경 할 수 있다.
-상수를 가리키는 상수 포인터는 자신이 가리키는 주소를 수정 할 수 없고 포인터가 가리키는 값도 수정 할 수 없다.
------------------------------------------------------------------------------------------------------------------------------const 참조자
void SH(const int %b){...}
- 콜바이레퍼런스여도 값이 변하지 않음 -
함수의 원형 선언만 봐도 값이 변하지 않음을 알 수 있음
실수로 인한 값의 변경이 일어나지 않음
const int n=10;
int &a = n;
const의 이유를 잃게 만드므로 컴파일에러
해결법
const int n=10;
const& ref =num;
const int& ref =50;
한번 const 선언이 들어가기 시작하면 관련해서 몇몇 변수들이 const
로 선언되어야 하는데, 이는 프로그램의 안젂성을 높이는 결과로 이어지기 때
문에, const 선언을 빈번히 하는 것은 좋은 습관이라 할 수 있다. 
------------------------------------------------------------------------------------------------------------------------------함수
메인문 내에 선언 불가
앞에 미리 선언시 메인문 위에 안써도 사용가능
기본인수 값을 적으면 디폴트로 인식(선언부나 내용부 둘중 하나에 값을 정해야함)
기본인수를 사용하려면 연속으로 값이 들어가므로 맨 오른쪽에는 무조건 있어야하며 3개 이상일 때 중간만 없어도 안됨 &&
------------------------------------------------------------------------------------------------------------------------------함수 - call by 밸류,레퍼런스
call by value 값만을 넘겨주므로 함수참조 이후 원본 값 변경x 
call by reference 주소값을 넘겨주므로 함수참조 이후 원본 값이 바뀔 수 있음
------------------------------------------------------------------------------------------------------------------------------함수 - 데이터 스택 힙
LIFO 방식
데이터영역: 전역변수 static변수 등 제일먼저생성 후 제일 나중에 없어짐
스택영역: 함수, 지역변수 등 컴파일에 크기가 정의되는 것들 비교적 빠르나 크기가 작아서 array[23409]등 불가 - 포인터로 힙영역에 넘기는 방법 사용
callby시리즈 모두 스택에 할당
힙영역: 런타임시 크기가 결정되는 것들 so int n=5;  int a[n]; 불가능
------------------------------------------------------------------------------------------------------------------------------오버로딩
함수의 이름은 같으나 인자는 다르게하는 것 리턴 자료형의 차이로는 불가능
인수에 값 지정하면 디폴트값으로 처리됨(함수 미리 선언시 디폴트값이 선언되고 후에 쓰이는 함수에는 안씀) 
기본인수를 사용하려면 연속으로 값이 들어가므로 맨 오른쪽에는 무조건 있어야하며 3개 이상일 때 중간만 없어도 안됨 &&
------------------------------------------------------------------------------------------------------------------------------inline함수
함수 호출시 점프하는 것이 아닌 코드 자체로 치환함
붙여도 안될 때, 안붙여도 될 때가 있음
남용시 오히려 비효과적
------------------------------------------------------------------------------------------------------------------------------매크로(define)
여러번 사용하게 될 상수를 문자로 표현하여 변경시에도 편리하게 사용할 수 있도록 하는 것
매크로 상수는 컴파일 전에 전처리기에 의해서 숫자로 단순 치환
define과 const의 차이
const에는 메모리가 할당, 컴파일러가 해당 메모리 영역에 덮어쓰는 작업을 막도록 감시하게 해줄 뿐이지, 주소를 직접 건드리는 경우에는 const의 값 역시 변경이 가능
 #define의 경우에는 메모리 할당이 일어나지 않으며 코딩의 편의에만 초점을 둠
------------------------------------------------------------------------------------------------------------------------------매크로(define)함수
매크로를 이용하여 함수의 역할을 대신 하는 것 ex) #define SUM(a,b) a+b
단순 치환을 하기 때문에 결과값이 다를 경우 존재 ex) #define MUL(a,b) a*b MUL(10+3, 20+2)는 전처리기에 의해
10+3 * 20 +2 로 계산이 되어 10+60+2 = 72가 나옴. 올바른 값은 #define MUL(a, b) ((a)*(b)) 와 같이 선언
------------------------------------------------------------------------------------------------------------------------------namespace
using 안씀 namespace ??{...}
namespace abc=aaa::bbb:ccc; 등 별칭 선언가능 (후에 abc:: 로 사용)
함수와 마찬가지로 메인문 앞에 있어야 인식
프로젝트 공동진행시 변수이름 충돌방지 등
같은 이름공간에 선언되면 동일공간으로 간주(SH네임스페이스 내에서 SH::로 정의 불가인듯 함)
이름공간 내에서 cout 등 함수 사용 불가인듯 함
이름공간을 명시하지 않고 함수 호출시 같은 이름공간 기준으로 호출됨
a::b::adder 등 중첩 및 계층적 구조 가능
전역변수 등은 따로 이름없이  ::만 쓰면 됨
------------------------------------------------------------------------------------------------------------------------------구조체
 struct Person{...}p1;  구조체 선언과 동시에 변수선언
 p1 = { .name = "홍길동", .age = 30, .address = "서울시 용산구 한남동" }; 
기본인수를 사용하려면 연속으로 값이 들어가므로 맨 오른쪽에는 무조건 있어야하며 3개 이상일 때 중간만 없어도 안됨 &&
------------------------------------------------------------------------------------------------------------------------------static
static 선언만 해도 0으로 자동 초기화
변수, 함수, 클래스, 구조체 앞에 선언
전역변수에 선언된 static 선언된 파일 내에서만 참조를 허용하겠다는 뜻
함수 내에 선언된 static 한번만 초기화되고, 지역변수와 달리 함수를 빠져나가도 소멸되지 않는다. 
static변수 지역변수의 사용범위지만 전역변수처럼 프로그램 시작시할당, 종료시 해제
함수를 빠져나가도 값이 유지됨 함수내 값 누적 가능
------------------------------------------------------------------------------------------------------------------------------new & delete (동적할당)
new
(1) 메모리 할당
(2) 생성자 호출
(3) 타입변환
delete
(1) 소멸자 호출
(2) 메모리 해제
int *ptr = new int;
delete prt;
double *ptr = new double[100];
delete []ptr;
참조자로도 힙 접근 가능
int *ptr = new int;
int &ref = *ptr;
ref=20;
------------------------------------------------------------------------------------------------------------------------------enum(열거형)
대문자로 시작, 변수는 모두 대문자가 일반적
같은 네임스페이스에 쓰이므로 변수명이 겹치면 오류
enum 열거형이름 {값1,값2,...}; https://jhnyang.tistory.com/427
첫 값은 0으로 매핑, 상수값을 초기화하면 변경가능 없는 상수는 앞의 값+1로 인식
switch와 자주 쓰이며 숫자 대신 열거형으로 상태를 나타낼 수 있으므로 가독성이 뛰어남
------------------------------------------------------------------------------------------------------------------------------this
this는 객체 자신의 포인터이다.
클래스의 멤버 함수 내에서만 사용할 수 있다.
개발자가 선언하는 변수가 아닌 컴파일러가 선언한 변수이다.
this가 필요한 경우
-매개변수의 이름과 멤버 변수의 이름이 같을 때
-멤버 함수가 객체 자신의 주소를 리턴할 때
this의 제약 사항
-멤버 함수가 아닌 함수에서 this 사용 불가
-static 멤버 함수에서 this 사용 불가
------------------------------------------------------------------------------------------------------------------------------상속
 class A : ? class B 에서 ?에 접근제한자를 설정하지 많으면 private로 상속
public시 지정변경 없음
protected시 public -> protected
private시 public,protected -> private
------------------------------------------------------------------------------------------------------------------------------다중상속
class A : 접근제한자 B, 접근제한자 C 
부모클래스 멤버이름 겹치면 오류발생 잘 쓰이지 않음
------------------------------------------------------------------------------------------------------------------------------생성자 소멸자
둘 다 리턴값이 없으며
생성자는 인스턴스 초기화, 소멸자는 인스턴스가 필요없어질 시 인스턴스 및 그로 인한 동적할당환경을 소거하기 위해 사용
각 인스턴스 당 생성자는 한개 이상 할당되어야 하며, 생성자는 다중정의가 가능하나 소멸자는 한개만 가능하다.
소멸자는 오버로딩 및 디폴트 매개변수 선언이 불가능하다
------------------------------------------------------------------------------------------------------------------------------오버로딩 오버라이딩
오버로딩: 같은 함수 이름 인자를 다르게 하여 재정의
오버라이딩: 상속시 부모객체의 함수를 재정의
------------------------------------------------------------------------------------------------------------------------------가상함수
함수 앞에 virtual을 붙여 사용
부모와 자식에 각각 이름/인수가 같은 함수가 있을 때 부모 객체형 포인터로 자식 객체의 함수를 가리킬 경우, 
컴파일 시 이미 부모클래스의 인스턴스로 결정이 되므로 부모 함수가 실행된다. 그러나 가상함수는 자식객체함수로 올바르게 동작한다.
-> 일반 함수/변수/인스턴스 들은 컴파일 시 값/실행내용이 결정되지만, virtual함수는 런타임에 결정된다. 따라서 런타임 중 변화를 캐치하여 동작했다.
------------------------------------------------------------------------------------------------------------------------------순수가상함수
virtual 리턴타입 함수명() =0; 으로 사용
상속시 자식개체에서 오버라이딩(재정의)가 필수적이며, 안할 시 컴파일 에러
함수가 공통적이지만 다른 요소가 있을 때 유용하며, 재정의 안할시 에러로 실수를 줄일 수 있음
------------------------------------------------------------------------------------------------------------------------------추상클래스
순수가상함수가 포함된 클래스
인스턴스 생성이 불가능하기에 완전한 클래스가 아니며 순수가상함수 이외의 것은 적지 않는게 효율적이다.
(순수가상함수가 아닌 다른 공통분모가 있을시 다른 클래스에 정의하여 다중상속한다.)
------------------------------------------------------------------------------------------------------------------------------추상함수
c++ 개념이 아닌듯 함
------------------------------------------------------------------------------------------------------------------------------파일분할
extern 으로 다른곳에 정의된 변수 사용함을 알림 (함수도 가능)
헤더에 정의를 적고 같은 이름의 소스에 상세구현
include "헤더/소스명"로 사용자정의 헤더 및 소스를 가져오며 메인문은 하나만 존재해야함
헤더를 여러 소스에서 호출하면 중복정의되므로 컴파일에러 - 소스도 구현부분이므로 마찬가지
------------------------------------------------------------------------------------------------------------------------------template
https://blog.naver.com/c16618/222616279670
template <typename T> / template <typename T1, typename T2> <- 여러개선언
T sh(int a, T b){...}

template <>
char sh (char a, char b){...} <- 템플릿의 특수화


인자 형식을 지정하지 않아도 되며 구조체 객체 클래스 등도 가능함

형식 T는 한번 정해지면 고정되므로  template <typename T> int sh(T a, T b)일 때 각각 자료형 다르게 불가
(자료형이 다를시 앞에 쓰여진 a의 형식으로 고정되며 b값 형식 다를시 컴파일에러 발생)

마찬가지로 특수화의 경우에도 앞에 쓰인형식대로 사용해야함
------------------------------------------------------------------------------------------------------------------------------Vector
배열보다 속도는 떨어지지만 메모리를 동적으로 효율적으로 관리하고 에외처리가 쉬움

v.end() 배열과 같이 끝주소에는 구분용(공백?, 쓰레기값?)이 들어가있는듯함
따라서 출력시 v.end()-1까지 해야함에 주의

v.erase(시작주소, 끝주소) : 끝주소 "앞"까지 지움
push_front가 존재하지 않아서 insert로 대체해야함
resize(index) 유용할듯

함수
https://coding-factory.tistory.com/596

------------------------------------------------------------------------------------------------------------------------------iterator(반복자)
STL클래스 내부에 만들어진, SLT안의 데이터를 가리키는 일종의 포인터
-> 배열의 포인터와 같이 STL에 통합된 포인터 개념을 사용하기 위해 사용
컨테이너 내부의 원소를 순회하며 접근방법을 제공하며, 컨테이너의 검색,삭제, 복사 등의 동작을 가능하게끔
중간에서 인터페이스 역할을 한다

내부요소식별/해당 요소 저장값 검사/ 요소사이의 이동연산/효율적 사용을 위한 연산제한 등

vector<string>::iterator iter = v.begin();
    for (iter; iter != v.end(); iter++)
        cout << *iter << " ";

값 넣기(push)이전에 이터레이터가 벡터를 가리키게하면 출력시 오류발생
->for문에서 정의를 할수도 있음

reverse_iterator > rbegin(),rend() 역순참조
const_iterator > cbegin(),cend() -> 값 변경없이 참조만할 때
const_reverse_iterator > crbegin(),crend() 가능한듯? (reverse_const는 불가한듯)


rbegin(),rend()를 통해 역순출력 가능하며, 
v.end()에서 v.begin()까지 for문을 돌리고 iter--하면 첫 원소 출력안됨
-> 쓰레기값+(원소-1)까지 출력되기 때문

vector에서 설명한 것과 같이, 
v.end()-1까지만 값이 들어있으므로 iter != v.end()로 설정해야함에 주의

iter = v.begin(); 으로 놓았을 때, 포인터이므로
iter[0], iter[1], iter[2] 등으로도 동작 가능

이터레이터를 선언하여 컨테이너(벡터 등)의 주소에 놓고,
iter값을 조정하여 해당 값(*iter)을 동작한다


queue,stack등은 이터레이터를 안쓰는듯 함(자바는 쓰는듯?)

가능연산
iter++, iter--
iter1==iter2, iter1!=iter2
iter+=2 등
* 연산자가 아니라 함수의 오버로딩으로 구현한 것으로 iter1+iter2등의 연산은 불가능
------------------------------------------------------------------------------------------------------------------------------auto
컴파일러가 초기에 입력된 값에따라 자료형식을 지정해줌
->컴파일시 형식이 지정되고 이후 값을 변경하더라도 바뀌지 않음
auto A = 3;

int& ARef = A;
const int AConst = A;

auto Test1 = ARef;    // int
auto Test2 = AConst;  // int
에서, auto의 타입은 둘다 무시하고 int 자료형으로 잡힘
따라서 &, const를 auto 키워드에 붙여주려고 할 경우에는 &, const를 명시해줘야함
즉,  auto&   const auto 처럼 사용 해야 한다는 것이죠

편리하지만 자료형이 무엇인지 다시한번 찾아야해서 가독성이 떨어지며,
1.234의 경우 float인지, double인지 모호해서 무조건 double(더 큰것)로 취급하기 때문에 메모리측면에서도 효율적이지 못함
주로 STL을 사용하고 iterator을 이용하는 부분에서 사용
------------------------------------------------------------------------------------------------------------------------------for_each문
알고리듬 헤더에 포함 (안써도 되던데 왜 그런지 모르겠음)
(for 변수명 : 대상변수명)
대상변수의 크기만큼 가변적으로 대입시켜 반복
변수명으로 동작구현
------------------------------------------------------------------------------------------------------------------------------deque
#include <deque> 헤더필요
dequeue랑 다름(이건 큐의 앞부분 말하는듯)

https://blockdmask.tistory.com/73